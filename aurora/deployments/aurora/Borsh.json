{
  "address": "0xE0fBAd1CF594081cb2dd4fc14C38F8329C2896E9",
  "abi": [],
  "transactionHash": "0x49d048a02b93a86794c3bc6a560baa17f5bd49727412c929621e557defd4ad96",
  "receipt": {
    "to": null,
    "from": "0x85fbC7b5087cC7b4Fe3Fe97755D8E01c9Fd727D9",
    "contractAddress": "0xE0fBAd1CF594081cb2dd4fc14C38F8329C2896E9",
    "transactionIndex": 0,
    "gasUsed": "72281",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x5125e8428937b8aee2f642a07019e23305bbb7802ae71d1b7e3a07b9ef3f28a9",
    "transactionHash": "0x49d048a02b93a86794c3bc6a560baa17f5bd49727412c929621e557defd4ad96",
    "logs": [],
    "blockNumber": 105700089,
    "cumulativeGasUsed": "0",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "8225b952b5cd1d11c318c3f3a3649c04",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/AuroraSDK/Borsh.sol\":\"Borsh\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/AuroraSDK/Borsh.sol\":{\"content\":\"// SPDX-License-Identifier: CC-BY-1.0\\n// https://github.com/aurora-is-near/native-erc20-connector\\n// https://github.com/aurora-is-near/native-erc20-connector\\npragma solidity ^0.8.17;\\n\\nimport \\\"./Utils.sol\\\";\\n\\nlibrary Borsh {\\n    using Borsh for Data;\\n\\n    struct Data {\\n        uint256 ptr;\\n        uint256 end;\\n    }\\n\\n    function from(bytes memory data) internal pure returns (Data memory res) {\\n        uint256 ptr;\\n        assembly {\\n            ptr := data\\n        }\\n        unchecked {\\n            res.ptr = ptr + 32;\\n            res.end = res.ptr + Utils.readMemory(ptr);\\n        }\\n    }\\n\\n    // This function assumes that length is reasonably small, so that data.ptr + length will not overflow. In the current code, length is always less than 2^32.\\n    function requireSpace(Data memory data, uint256 length) internal pure {\\n        unchecked {\\n            require(\\n                data.ptr + length <= data.end,\\n                \\\"Parse error: unexpected EOI\\\"\\n            );\\n        }\\n    }\\n\\n    function read(Data memory data, uint256 length)\\n        internal\\n        pure\\n        returns (bytes32 res)\\n    {\\n        data.requireSpace(length);\\n        res = bytes32(Utils.readMemory(data.ptr));\\n        unchecked {\\n            data.ptr += length;\\n        }\\n        return res;\\n    }\\n\\n    function done(Data memory data) internal pure {\\n        require(data.ptr == data.end, \\\"Parse error: EOI expected\\\");\\n    }\\n\\n    // Same considerations as for requireSpace.\\n    function peekKeccak256(Data memory data, uint256 length)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        data.requireSpace(length);\\n        return Utils.keccak256Raw(data.ptr, length);\\n    }\\n\\n    // Same considerations as for requireSpace.\\n    function peekSha256(Data memory data, uint256 length)\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        data.requireSpace(length);\\n        return Utils.sha256Raw(data.ptr, length);\\n    }\\n\\n    function decodeU8(Data memory data) internal pure returns (uint8) {\\n        return uint8(bytes1(data.read(1)));\\n    }\\n\\n    function decodeU16(Data memory data) internal pure returns (uint16) {\\n        return Utils.swapBytes2(uint16(bytes2(data.read(2))));\\n    }\\n\\n    function decodeU32(Data memory data) internal pure returns (uint32) {\\n        return Utils.swapBytes4(uint32(bytes4(data.read(4))));\\n    }\\n\\n    function decodeU64(Data memory data) internal pure returns (uint64) {\\n        return Utils.swapBytes8(uint64(bytes8(data.read(8))));\\n    }\\n\\n    function decodeU128(Data memory data) internal pure returns (uint128) {\\n        return Utils.swapBytes16(uint128(bytes16(data.read(16))));\\n    }\\n\\n    function decodeU256(Data memory data) internal pure returns (uint256) {\\n        return Utils.swapBytes32(uint256(data.read(32)));\\n    }\\n\\n    function decodeBytes20(Data memory data) internal pure returns (bytes20) {\\n        return bytes20(data.read(20));\\n    }\\n\\n    function decodeBytes32(Data memory data) internal pure returns (bytes32) {\\n        return data.read(32);\\n    }\\n\\n    function decodeBool(Data memory data) internal pure returns (bool) {\\n        uint8 res = data.decodeU8();\\n        require(res <= 1, \\\"Parse error: invalid bool\\\");\\n        return res != 0;\\n    }\\n\\n    function skipBytes(Data memory data) internal pure {\\n        uint256 length = data.decodeU32();\\n        data.requireSpace(length);\\n        unchecked {\\n            data.ptr += length;\\n        }\\n    }\\n\\n    function decodeBytes(Data memory data)\\n        internal\\n        pure\\n        returns (bytes memory res)\\n    {\\n        uint256 length = data.decodeU32();\\n        data.requireSpace(length);\\n        res = Utils.memoryToBytes(data.ptr, length);\\n        unchecked {\\n            data.ptr += length;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1a3704c81feec760578cfbfb2ec7038d9dbffda15d3f5706946fecbcd13e869d\",\"license\":\"CC-BY-1.0\"},\"contracts/AuroraSDK/Utils.sol\":{\"content\":\"// SPDX-License-Identifier: CC-BY-1.0\\n// https://github.com/aurora-is-near/native-erc20-connector\\npragma solidity ^0.8.17;\\n\\nlibrary Utils {\\n    function swapBytes2(uint16 v) internal pure returns (uint16) {\\n        return (v << 8) | (v >> 8);\\n    }\\n\\n    function swapBytes4(uint32 v) internal pure returns (uint32) {\\n        v = ((v & 0x00ff00ff) << 8) | ((v & 0xff00ff00) >> 8);\\n        return (v << 16) | (v >> 16);\\n    }\\n\\n    function swapBytes8(uint64 v) internal pure returns (uint64) {\\n        v = ((v & 0x00ff00ff00ff00ff) << 8) | ((v & 0xff00ff00ff00ff00) >> 8);\\n        v = ((v & 0x0000ffff0000ffff) << 16) | ((v & 0xffff0000ffff0000) >> 16);\\n        return (v << 32) | (v >> 32);\\n    }\\n\\n    function swapBytes16(uint128 v) internal pure returns (uint128) {\\n        v =\\n            ((v & 0x00ff00ff00ff00ff00ff00ff00ff00ff) << 8) |\\n            ((v & 0xff00ff00ff00ff00ff00ff00ff00ff00) >> 8);\\n        v =\\n            ((v & 0x0000ffff0000ffff0000ffff0000ffff) << 16) |\\n            ((v & 0xffff0000ffff0000ffff0000ffff0000) >> 16);\\n        v =\\n            ((v & 0x00000000ffffffff00000000ffffffff) << 32) |\\n            ((v & 0xffffffff00000000ffffffff00000000) >> 32);\\n        return (v << 64) | (v >> 64);\\n    }\\n\\n    function swapBytes32(uint256 v) internal pure returns (uint256) {\\n        v =\\n            ((v &\\n                0x00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff) <<\\n                8) |\\n            ((v &\\n                0xff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00) >>\\n                8);\\n        v =\\n            ((v &\\n                0x0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff) <<\\n                16) |\\n            ((v &\\n                0xffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000) >>\\n                16);\\n        v =\\n            ((v &\\n                0x00000000ffffffff00000000ffffffff00000000ffffffff00000000ffffffff) <<\\n                32) |\\n            ((v &\\n                0xffffffff00000000ffffffff00000000ffffffff00000000ffffffff00000000) >>\\n                32);\\n        v =\\n            ((v &\\n                0x0000000000000000ffffffffffffffff0000000000000000ffffffffffffffff) <<\\n                64) |\\n            ((v &\\n                0xffffffffffffffff0000000000000000ffffffffffffffff0000000000000000) >>\\n                64);\\n        return (v << 128) | (v >> 128);\\n    }\\n\\n    function readMemory(uint256 ptr) internal pure returns (uint256 res) {\\n        assembly {\\n            res := mload(ptr)\\n        }\\n    }\\n\\n    function writeMemory(uint256 ptr, uint256 value) internal pure {\\n        assembly {\\n            mstore(ptr, value)\\n        }\\n    }\\n\\n    function memoryToBytes(uint256 ptr, uint256 length)\\n        internal\\n        pure\\n        returns (bytes memory res)\\n    {\\n        if (length != 0) {\\n            assembly {\\n                // 0x40 is the address of free memory pointer.\\n                res := mload(0x40)\\n                let end := add(\\n                    res,\\n                    and(\\n                        add(length, 63),\\n                        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\\n                    )\\n                )\\n                // end = res + 32 + 32 * ceil(length / 32).\\n                mstore(0x40, end)\\n                mstore(res, length)\\n                let destPtr := add(res, 32)\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    mstore(destPtr, mload(ptr))\\n                    destPtr := add(destPtr, 32)\\n                    if eq(destPtr, end) { break }\\n                    ptr := add(ptr, 32)\\n                }\\n            }\\n        }\\n    }\\n\\n    function keccak256Raw(uint256 ptr, uint256 length)\\n        internal\\n        pure\\n        returns (bytes32 res)\\n    {\\n        assembly {\\n            res := keccak256(ptr, length)\\n        }\\n    }\\n\\n    function sha256Raw(uint256 ptr, uint256 length)\\n        internal\\n        view\\n        returns (bytes32 res)\\n    {\\n        assembly {\\n            // 2 is the address of SHA256 precompiled contract.\\n            // First 64 bytes of memory can be used as scratch space.\\n            let ret := staticcall(gas(), 2, ptr, length, 0, 32)\\n            // If the call to SHA256 precompile ran out of gas, burn any gas that remains.\\n            // prettier-ignore\\n            for {} iszero(ret) {} {}\\n            res := mload(0)\\n        }\\n    }\\n\\n    /// Convert array of bytes to hexadecimal string.\\n    /// https://ethereum.stackexchange.com/a/126928/45323\\n    function bytesToHex(bytes memory buffer)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        // Fixed buffer size for hexadecimal convertion\\n        bytes memory converted = new bytes(buffer.length * 2);\\n\\n        bytes memory _base = \\\"0123456789abcdef\\\";\\n\\n        for (uint256 i = 0; i < buffer.length; i++) {\\n            converted[i * 2] = _base[uint8(buffer[i]) / _base.length];\\n            converted[i * 2 + 1] = _base[uint8(buffer[i]) % _base.length];\\n        }\\n\\n        return string(converted);\\n    }\\n}\\n\",\"keccak256\":\"0xff8fdd1fc95ec1ab0f94ababeafdeea46fc110367cfed77c43a17c2f4fd03a9c\",\"license\":\"CC-BY-1.0\"}},\"version\":1}",
  "bytecode": "0x60566050600b82828239805160001a6073146043577f4e487b7100000000000000000000000000000000000000000000000000000000600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122094361af94f483efa1dd58a838b41140a1d5a848670330d93cbb51aa5ec261aad64736f6c63430008110033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122094361af94f483efa1dd58a838b41140a1d5a848670330d93cbb51aa5ec261aad64736f6c63430008110033",
  "libraries": {
    "Utils": "0xa2d8aA38549c2eebdF2FD11Faa09ad0132823a96"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}