# Comments relates to Figma screen names.
# Names according to Figma. Suffix according to api list, details

type GraphNetwork @entity {
  "ID is set to 1"
  id: ID!  # for example trick thanks to https://github.com/graphprotocol/graph-network-analytics-subgraph/blob/00d32f153f7b6bcef4344b934e3c9a9286304658/schema.graphql#L4.
  # TODO: remove when total field wil be added by developers.
  # https://github.com/graphprotocol/graph-node/issues/613
  providersTotal: BigInt!
  dealsTotal: BigInt!
  offersTotal: BigInt!
  tokensTotal: BigInt!
  effectorsTotal: BigInt!
  # Add constants from Core contract below.
  coreEpochDuration: Int
  initTimestamp: Int
  # Capacity consts are below.
  capacityMaxFailedRatio: Int
}

type Token @entity(immutable: true) {
  id: ID!  # Token Address
  symbol: String!
  decimals: Int!
}

type Provider @entity {
  id: ID!
  name: String!
  createdAt: BigInt!
  approved: Boolean!

  offers: [Offer!] @derivedFrom(field: "provider")

  # Add Statistics below.
  computeUnitsAvailable: Int!  # Sum of all available compute units in the offer (not in the deals).
  computeUnitsTotal: Int!  # Sum of all compute units registered in the offer. TODO: when CU deleted?
  peerCount: Int!
}

# ---- Core Contract ----
type Offer @entity {
  """Used in the next figma views:
    - Offer from List Of offers 1.2.
    - Offer 1.2
  """
  id: ID!  # Ref to offerId in contract.
  createdAt: BigInt!
  updatedAt: BigInt!
  provider: Provider!
#   TODO: price per epoch and price per worker epoch are the same essentials?
  pricePerEpoch: BigInt!
  paymentToken: Token!

  peers: [Peer!] @derivedFrom(field: "offer")
  effectors: [OfferToEffector!] @derivedFrom(field: "offer")

  # Add Statistics below.
  computeUnitsAvailable: Int  # Sum of all available compute units in the offer (not in the deals).
  computeUnitsTotal: Int  # Sum of all compute units registered in the offer. TODO: when CU deleted?

  # Add helpers fields to support some queries below.
  "To support check that a peer already in a deal."
  joinedOfferPeers: [DealToJoinedOfferPeer!] @derivedFrom(field: "offer")
}


"""To support many2many b/w offer and effector.
E.g. to use
{
  offers {
    effectors {
      effector {
        description
      }
    }
  }
}
"""
type OfferToEffector @entity {
    id: ID! # Set to `user.id.concat(organization.id)`
    offer: Offer!
    effector: Effector!
}


"Effector table is obsolete table since it is a simple mapping."
type Effector @entity {
  "id and CID are the same."
  id: ID!  # Currently effector id is merged(prefix + hash) aka 1 CID.
  description: String!
  offers: [OfferToEffector!] @derivedFrom(field: "effector")
}

type Peer @entity {
  "ref to peerId in contract."
  id: ID!
  offer: Offer!
  provider: Provider!
  computeUnits: [ComputeUnit!] @derivedFrom(field: "peer")

  currentCapacityCommitment: CapacityCommitment
  "To access history of capacity commitments."
  capacityCommitments: [CapacityCommitment!] @derivedFrom(field: "peer")

  # Indexer query helper fields below (named with prefix of already existed field, e.g. currentCapacityCommitment).
  "To understand if collateral for peer have been submitted. This field should be use in conjunction with currentCapacityCommitment."
  currentCCCollateralDepositedAt: BigInt
  currentCCEndEpoch: BigInt
  currentCCNextCCFailedEpoch: BigInt

  # We need field to query from perspective of Peer on deal field.
  joinedDeals: [DealToPeer!] @derivedFrom(field: "peer")
  # To make query with OR to retrieve even entities with joinedDeals == [].
  # TODO: create issue on Subgraph for the feature and past here.
  isAnyJoinedDeals: Boolean!
}

type ComputeUnit @entity {
  id: ID!
  peer: Peer!
  "In order to simplify relation for query."
  provider: Provider!

  deal: Deal
  workerId: String
  # TODO: worker status "Expired" how to calculate.
}

# ---- Deal Contract ----
type DealToEffector @entity(immutable: true) {
    id: ID! # Set to `deal.id.concat(effector.id)`
    deal: Deal!
    effector: Effector!
}

type DealToPeer @entity(immutable: true) {
    id: ID! # Set to `deal.id.concat(peer.id)`
    deal: Deal!
    peer: Peer!
}

"""
TODO: deprecate.
To add possibility to filter already joined peers into a Deal from perspective of an Offer
(protocol does not allow more than one CU per peer for the same Deal).
"""
type DealToJoinedOfferPeer @entity(immutable: true) {
    id: ID! # Set to `deal.id.concat(offer.id.concat(peer.id))`
    deal: Deal!
    offer: Offer!  # search offers initially using this fk relation.
    peer: Peer!
}

"It represents m2m b/w deal and provider in context of access list."
type DealToProvidersAccess @entity(immutable: true) {
  id: ID! # Set to `deal.id.concat(provider.id)`
  deal: Deal!
  provider: Provider!
}

type Deal @entity {
  id: ID!  # Ref to offerId in contract.
  appCID: String!
  createdAt: BigInt!
  owner: String!
  # Settings from public methods.
  minWorkers: Int!
  targetWorkers: Int!
  maxWorkersPerProvider: Int!
  paymentToken: Token!
  pricePerWorkerEpoch: BigInt!
  effectors: [DealToEffector!] @derivedFrom(field: "deal")
  "Many to many to access joined peers to maintain protocol restrictions"
  joinedPeers: [DealToPeer!] @derivedFrom(field: "deal")
  "It represents AccessType of Deal contract."
  providersAccessType: Int!
  providersAccessList: [DealToProvidersAccess!] @derivedFrom(field: "deal")
  #  balance: BigInt!  # on-request via frontend
  #  status: DealStatus!  # on-request via frontend

  # Add Statistics below.
  withdrawalSum: BigInt!
  depositedSum: BigInt!  # calculated from the withdraw() [no rewards withdraw].
  maxPaidEpoch: BigInt

  "I.e. Matching Result (Figma)."
  addedComputeUnits: [ComputeUnit!] @derivedFrom(field: "deal")
  #   TODO: add matched workers.
}

enum CapacityCommitmentStatus {
  Active
  WaitDelegation
  WaitStart
  Inactive
  Failed
  Removed
}

"""To represent that Peer has capacity commitment for some time."""
type CapacityCommitment @entity {
  id: ID!
  peer: Peer!
  "This status represents last stored status on chain (status that does not depends on the current epoch some how)."
  status: CapacityCommitmentStatus
  collateralPerUnit: BigInt!
  duration: BigInt!
  rewardDelegatorRate: Int!
  delegator: String!
  startEpoch: BigInt!
  endEpoch: BigInt!
  totalCUFailCount: Int!
  failedEpoch: BigInt!
  exitedUnitCount: Int!
  activeUnitCount: Int!
  nextAdditionalActiveUnitCount: Int!
  unitCount: Int!
  snapshotEpoch: BigInt!
  "If CC deleted before collateral deposited."
  deleted: Boolean!
  "Calculated in subgraph field: next failed epoch means the next epoch without proofs submitted when CC declared to be Failed."
  nextCCFailedEpoch: BigInt!
}
