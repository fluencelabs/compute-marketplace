# Comments relates to Figma screen names.
# Names according to Figma. Suffix according to api list, details

type GraphNetwork @entity {
  "ID is set to 1"
  id: ID!  # for example trick thanks to https://github.com/graphprotocol/graph-network-analytics-subgraph/blob/00d32f153f7b6bcef4344b934e3c9a9286304658/schema.graphql#L4.
  # TODO: remove when total field wil be added by developers.
  # https://github.com/graphprotocol/graph-node/issues/613
  providersTotal: BigInt!
  dealsTotal: BigInt!
  offersTotal: BigInt!
  tokensTotal: BigInt!
  effectorsTotal: BigInt!
  # Add constants from Core contract below.
  coreEpochDuration: Int
  initTimestamp: Int
}

type Token @entity(immutable: true) {
  id: ID!  # Token Address
  symbol: String!
  decimals: Int!
}

type Provider @entity {
  id: ID!
  name: String!
  createdAt: BigInt!

  offers: [Offer!] @derivedFrom(field: "provider")

  # Add Statistics below.
  computeUnitsAvailable: Int!  # Sum of all available compute units in the offer (not in the deals).
  computeUnitsTotal: Int!  # Sum of all compute units registered in the offer. TODO: when CU deleted?
  peerCount: Int!
  effectorCount: Int!
}

# ---- Core Contract ----
type Offer @entity {
  """Used in the next figma views:
    - Offer from List Of offers 1.2.
    - Offer 1.2
  """
  id: ID!  # Ref to offerId in contract.
  createdAt: BigInt!
  updatedAt: BigInt!
  provider: Provider!
#   TODO: price per epoch and price per worker epoch are the same essentials?
  pricePerEpoch: BigInt!
  paymentToken: Token!

  peers: [Peer!] @derivedFrom(field: "offer")
  effectors: [OfferToEffector!] @derivedFrom(field: "offer")

  # Add Statistics below.
  computeUnitsAvailable: Int  # Sum of all available compute units in the offer (not in the deals).
  computeUnitsTotal: Int  # Sum of all compute units registered in the offer. TODO: when CU deleted?

  # Add helpers fields to support some queries below.
  "To support check that a peer already in a deal."
  joinedOfferPeers: [DealToJoinedOfferPeer!] @derivedFrom(field: "offer")
}


"""To support many2many b/w offer and effector.
E.g. to use
{
  offers {
    effectors {
      effector {
        description
      }
    }
  }
}
"""
type OfferToEffector @entity {
    id: ID! # Set to `user.id.concat(organization.id)`
    offer: Offer!
    effector: Effector!
}


"Effector table is obsolete table since it is a simple mapping."
type Effector @entity {
  "id and CID are the same."
  id: ID!  # Currently effector id is merged(prefix + hash) aka 1 CID.
  description: String!
  offers: [OfferToEffector!] @derivedFrom(field: "effector")
}

type Peer @entity {
  "ref to peerId in contract."
  id: ID!
  offer: Offer!
  provider: Provider!
  computeUnits: [ComputeUnit!] @derivedFrom(field: "peer")

  currentCapacityCommitment: CapacityCommitment
  "To access history of capacity commitments."
  capacityCommitments: [CapacityCommitment!] @derivedFrom(field: "peer")

  # Indexer query helper fields below.
  "To understand if collateral for peer have been submitted. This field should be use in conjunction with currentCapacityCommitment."
  capacityFieldCollateralDepositedAt: BigInt


  # We need field to query from perspective of Peer on deal field.
  joinedDeals: [DealToPeer!] @derivedFrom(field: "peer")
  # To make query with OR to retrieve even entities with joinedDeals == [].
  # TODO: create issue on Subgraph for the feature and past here.
  isAnyJoinedDeals: Boolean!
}

type ComputeUnit @entity {
  id: ID!
  peer: Peer!
  "In order to simplify relation for query."
  provider: Provider!

  deal: Deal
  workerId: String
  # TODO: worker status "Expired" how to calculate.
}

# ---- Deal Contract ----
type DealToEffector @entity(immutable: true) {
    id: ID! # Set to `deal.id.concat(effector.id)`
    deal: Deal!
    effector: Effector!
}

type DealToPeer @entity(immutable: true) {
    id: ID! # Set to `deal.id.concat(peer.id)`
    deal: Deal!
    peer: Peer!
}

"""
TODO: deprecate.
To add possibility to filter already joined peers into a Deal from perspective of an Offer
(protocol does not allow more than one CU per peer for the same Deal).
"""
type DealToJoinedOfferPeer @entity(immutable: true) {
    id: ID! # Set to `deal.id.concat(offer.id.concat(peer.id))`
    deal: Deal!
    offer: Offer!  # search offers initially using this fk relation.
    peer: Peer!
}

type Deal @entity {
  id: ID!  # Ref to offerId in contract.
  appCID: String!
  createdAt: BigInt!
  owner: String!
  # Settings from public methods.
  minWorkers: Int!
  targetWorkers: Int!
  maxWorkersPerProvider: Int!
  paymentToken: Token!
  pricePerWorkerEpoch: BigInt!
  effectors: [DealToEffector!] @derivedFrom(field: "deal")
  "Many to many to access joined peers to maintain protocol restrictions"
  joinedPeers: [DealToPeer!] @derivedFrom(field: "deal")
  # TODO: add whitelists...
  # TODO: add blacklists...
  #  balance: BigInt!  # on-request via frontend
  #  status: DealStatus!  # on-request via frontend

  # Add Statistics below.
  withdrawalSum: BigInt!
  depositedSum: BigInt!  # calculated from the withdraw() [no rewards withdraw].
  maxPaidEpoch: BigInt

  "I.e. Matching Result (Figma)."
  addedComputeUnits: [ComputeUnit!] @derivedFrom(field: "deal")
  #   TODO: add matched workers.
}

enum CapacityCommitmentStatus {
  Active
  WaitDelegation
  Inactive
  Failed
  Removed
}

"""To represent that Peer has capacity commitment for some time."""
type CapacityCommitment @entity {
  id: ID!
  peer: Peer!
  # TODO: status on storage does not give right status as it is from getStatus() method.
  # TODO: add required property.
  CCStatus: CapacityCommitmentStatus
  collateralPerUnit: BigInt!
  duration: BigInt!
  rewardDelegatorRate: Int!
  delegator: String!
  startEpoch: BigInt!
  endEpoch: BigInt!
  totalCUFailCount: Int!
  failedEpoch: BigInt!
  exitedUnitCount: Int!
  #  TODO: store CUs.
  unitCount: Int!
  nextCCFailedEpoch: BigInt!
}
